# ------------------------------------------------------------------------------
#  Auto Merge on Approval Workflow
#
#  Purpose: Automatically merge PRs once all approval and CI conditions pass.
#
#  Triggers: Pull request events, review submissions, and completed checks.
#
#  Maintainer: @mrz1836
#
#  Rules for Auto-Merge:
#    • At least 1 approval review is required.
#    • No requested reviewers must remain.
#    • No reviews with "Changes Requested" status.
#    • All required status checks must pass:
#        - test (1.22.x, ubuntu-latest)
#        - test (1.23.x, ubuntu-latest)
#        - test (1.24.x, ubuntu-latest)
#        - Analyze (go)
#    • PR title must not contain "WIP" (case-insensitive).
#    • PR must not have the "work-in-progress" label.
#    • PR must not be a draft.
# ------------------------------------------------------------------------------

name: auto-merge-on-approval

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review, labeled, unlabeled, edited]
  pull_request_review:
    types: [submitted]
  check_suite:
    types: [completed]
  status: {}

# Cancel older runs of the same PR if a new commit is pushed
concurrency:
    group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
    cancel-in-progress: true

permissions:
  contents: write
  pull-requests: write

jobs:
  automerge:
    if: >-
      github.actor != 'dependabot[bot]' &&
      github.actor != 'dependabot-preview[bot]' &&
      github.actor != 'codecov[bot]'
    runs-on: ubuntu-latest
    steps:
      - name: Attempt auto-merge
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            let pr;
            try {
              pr = context.payload.pull_request;
              if (!pr) {
                // Try to find PR by commit SHA for check_suite/status events
                const sha = context.payload.check_suite?.head_sha || context.payload.sha;
                if (sha) {
                  const { data: prs } = await github.rest.pulls.list({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    head: `${context.repo.owner}:${sha}`,
                    state: 'open',
                  });
                  pr = prs[0];
                }
              }
              if (!pr) throw { status: 404 };
            } catch (err) {
              if (err.status === 404) {
                core.info('PR not found (may be closed or deleted), skipping.');
                return;
              } else {
                throw err;
              }
            }
            const prNumber = pr.number;
            const title = pr.title || "";
            const labels = pr.labels.map(l => l.name);
            const isDraft = pr.draft;

            // Fetch reviews
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });
            const approvals = reviews.filter(r => r.state === 'APPROVED').length;
            const changesRequested = reviews.filter(r => r.state === 'CHANGES_REQUESTED').length;

            // Fetch requested reviewers
            const requestedReviewers = pr.requested_reviewers || [];

            // Fetch check runs for the latest commit
            const sha = pr.head.sha;
            const { data: checks } = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: sha,
            });
            const requiredChecks = [
              'test (1.22.x, ubuntu-latest)',
              'test (1.23.x, ubuntu-latest)',
              'test (1.24.x, ubuntu-latest)',
              'Analyze (go)',
            ];
            // Use check_runs instead of undefined statuses
            const checkRuns = checks.check_runs || [];
            const checksPass = requiredChecks.every(name => {
              const run = checkRuns.find(c => c.name === name);
              return run && run.conclusion === 'success';
            });

            const titleHasWip = /wip/i.test(title);
            const hasWipLabel = labels.includes('work-in-progress');

            // Wrap merge in try/catch for error handling
            // Verbose output for unmet conditions
            if (
              approvals >= 1 &&
              requestedReviewers.length === 0 &&
              changesRequested === 0 &&
              checksPass &&
              !titleHasWip &&
              !hasWipLabel &&
              !isDraft
            ) {
              try {
                await github.rest.pulls.merge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  merge_method: 'merge',
                });
                console.log(`Pull request #${prNumber} merged.`);
              } catch (error) {
                core.setFailed(`Failed to merge PR #${prNumber}: ${error.message}`);
              }
            } else {
              if (approvals < 1) {
                console.log('Auto-merge not performed: Less than 1 approval.');
              }
              if (requestedReviewers.length > 0) {
                console.log('Auto-merge not performed: There are still requested reviewers.');
              }
              if (changesRequested > 0) {
                console.log('Auto-merge not performed: There are reviews with "Changes Requested".');
              }
              if (!checksPass) {
                // Find which checks did not pass
                const failedChecks = requiredChecks.filter(name => {
                  const run = checkRuns.find(c => c.name === name);
                  return !(run && run.conclusion === 'success');
                });
                console.log(`Auto-merge not performed: The following required checks did not pass: ${failedChecks.join(', ')}`);
              }
              if (titleHasWip) {
                console.log('Auto-merge not performed: PR title contains "WIP".');
              }
              if (hasWipLabel) {
                console.log('Auto-merge not performed: PR has the "work-in-progress" label.');
              }
              if (isDraft) {
                console.log('Auto-merge not performed: PR is a draft.');
              }
            }
